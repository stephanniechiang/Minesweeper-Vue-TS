{"remainingRequest":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/babel-loader/lib/index.js!/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/ts-loader/index.js??ref--13-2!/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/src/components/MineField.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/src/components/MineField.vue","mtime":1600575833537},{"path":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { __decorate } from \"tslib\";\nimport { Component, Prop, Vue } from 'vue-property-decorator';\nimport FieldCell from './FieldCell.vue';\nimport MousePosition from '../others/MousePosition';\nlet MineField = class MineField extends Vue {\n  constructor() {\n    super(...arguments);\n    this.activeMineField = true;\n    this.cells = [];\n    this.flaggedMines = 0;\n    this.minesGenerated = false;\n  }\n\n  handleReveal(cell) {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    this.revealCells(cell.row, cell.col);\n    this.$forceUpdate();\n  }\n\n  handleToggleFlag(cell) {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    this.cells[cell.row][cell.col].flagged = !cell.flagged;\n\n    if (this.cells[cell.row][cell.col].flagged) {\n      this.flaggedMines++;\n    } else {\n      this.flaggedMines--;\n    }\n\n    this.$emit('handle-flagged-mines', this.flaggedMines);\n    this.$forceUpdate();\n  }\n\n  handleSpace(e) {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    const el = document.elementFromPoint(MousePosition.x, MousePosition.y);\n\n    if (el) {\n      const parent = el.closest('.cell-wrapper');\n\n      if (!parent) {\n        return;\n      }\n\n      const rowString = parent.dataset.row;\n      const colString = parent.dataset.col;\n\n      if (rowString && colString) {\n        const row = Number(rowString);\n        const col = Number(colString);\n\n        if (this.validBoundaries(row, col)) {\n          const cell = this.cells[row][col];\n\n          if (cell.hidden) {\n            this.handleToggleFlag(cell);\n          } else if (!cell.hidden && cell.adjacentCells === this.calculateAdjacentFlaggedCells(row, col)) {\n            this.revealAdjacentUnflaggedCells(row, col);\n            this.$forceUpdate();\n          }\n        }\n      }\n    }\n  }\n\n  created() {\n    if (this.mines - 9 > this.rows * this.cols) {\n      this.mines = this.rows * this.cols - 9;\n    }\n\n    for (let row = 0; row < this.rows; row++) {\n      this.cells[row] = [];\n\n      for (let col = 0; col < this.cols; col++) {\n        this.cells[row][col] = {\n          row,\n          col,\n          mine: false,\n          exploded: false,\n          hidden: true,\n          flagged: false,\n          adjacentCells: 0\n        };\n      }\n    }\n\n    const minefield = this;\n    window.addEventListener('keypress', event => {\n      if (event.keyCode === 32) {\n        minefield.handleSpace(event);\n      }\n    });\n  }\n\n  updated() {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    this.$emit('handle-ingame');\n\n    if (this.checkLoseConditions()) {\n      this.$emit('handle-lose');\n      this.activeMineField = false;\n      this.revealAllCells();\n      this.$forceUpdate();\n    } else if (this.checkWinConditions()) {\n      this.$emit('handle-win');\n      this.activeMineField = false;\n      this.revealAllCells();\n      this.$forceUpdate();\n    }\n  }\n\n  getRandomInt(from, to) {\n    return Math.floor(Math.random() * to) + from;\n  }\n\n  generateMines(initRow, initCol) {\n    let minesToPlant = this.mines;\n\n    while (minesToPlant > 0) {\n      const row = this.getRandomInt(0, this.rows);\n      const col = this.getRandomInt(0, this.cols);\n\n      if (!this.cells[row][col].mine && (Math.abs(initRow - row) > 1 || Math.abs(initCol - col) > 1)) {\n        this.cells[row][col].mine = true;\n        minesToPlant--;\n      }\n    }\n\n    this.minesGenerated = true;\n    this.setAdjacentCells();\n  }\n\n  setAdjacentCells() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.cols; col++) {\n        this.cells[row][col].adjacentCells = this.calculateAdjacentCells(row, col);\n      }\n    }\n  }\n\n  validBoundaries(row, col) {\n    return row >= 0 && row < this.rows && col >= 0 && col < this.cols;\n  }\n\n  calculateAdjacentCells(row, col) {\n    let adjacentCells = 0;\n\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (this.validBoundaries(row + rowShift, col + colShift) && this.cells[row + rowShift][col + colShift].mine) {\n          adjacentCells += 1;\n        }\n      }\n    }\n\n    return adjacentCells;\n  }\n\n  calculateAdjacentFlaggedCells(row, col) {\n    let adjacentCells = 0;\n\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (this.validBoundaries(row + rowShift, col + colShift) && this.cells[row + rowShift][col + colShift].flagged) {\n          adjacentCells += 1;\n        }\n      }\n    }\n\n    return adjacentCells;\n  }\n\n  revealAllCells() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.cols; col++) {\n        this.cells[row][col].hidden = false;\n      }\n    }\n  }\n\n  revealCells(row, col) {\n    if (!this.minesGenerated) {\n      this.generateMines(row, col);\n    }\n\n    if (!this.cells[row][col].hidden || this.cells[row][col].flagged) {\n      return;\n    }\n\n    this.cells[row][col].hidden = false;\n\n    if (this.cells[row][col].mine) {\n      this.cells[row][col].exploded = true;\n    }\n\n    if (this.cells[row][col].adjacentCells > 0) {\n      return;\n    }\n\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (this.validBoundaries(row + rowShift, col + colShift)) {\n          this.revealCells(row + rowShift, col + colShift);\n        }\n      }\n    }\n  }\n\n  revealAdjacentUnflaggedCells(row, col) {\n    if (this.cells[row][col].flagged) {\n      return;\n    }\n\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (this.validBoundaries(row + rowShift, col + colShift) && !this.cells[row + rowShift][col + colShift].flagged) {\n          this.revealCells(row + rowShift, col + colShift);\n        }\n      }\n    }\n  }\n\n  checkWinConditions() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.cols; col++) {\n        if (this.cells[row][col].hidden && !this.cells[row][col].mine) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  checkLoseConditions() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.cols; col++) {\n        if (!this.cells[row][col].hidden && this.cells[row][col].mine) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n};\n\n__decorate([Prop()], MineField.prototype, \"rows\", void 0);\n\n__decorate([Prop()], MineField.prototype, \"cols\", void 0);\n\n__decorate([Prop()], MineField.prototype, \"mines\", void 0);\n\nMineField = __decorate([Component({\n  components: {\n    FieldCell\n  }\n})], MineField);\nexport default MineField;",{"version":3,"sources":["/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/stephanniechiang/Documents/Personal/Minesweeper-Vue-TS/src/components/MineField.vue?vue&type=script&lang=ts&"],"names":[],"mappings":"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","sourcesContent":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Prop, Watch, Vue } from 'vue-property-decorator';\n\nimport FieldCell from './FieldCell.vue';\nimport Cell from '../definitions/Cell';\nimport MousePosition from '../others/MousePosition';\n\n@Component({\n  components: {\n    FieldCell,\n  },\n})\nexport default class MineField extends Vue {\n  @Prop() public rows!: number;\n  @Prop() public cols!: number;\n  @Prop() public mines!: number;\n\n  public activeMineField: boolean = true;\n\n  public cells: Cell[][] = [];\n\n  public flaggedMines: number = 0;\n\n  public minesGenerated: boolean = false;\n\n  public handleReveal(cell: Cell) {\n    if (!this.activeMineField) {\n      return;\n    }\n    this.revealCells(cell.row, cell.col);\n\n    this.$forceUpdate();\n  }\n\n  public handleToggleFlag(cell: Cell) {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    this.cells[cell.row][cell.col].flagged = !cell.flagged;\n\n    if (this.cells[cell.row][cell.col].flagged) {\n      this.flaggedMines++;\n    } else {\n      this.flaggedMines--;\n    }\n    this.$emit('handle-flagged-mines', this.flaggedMines);\n\n    this.$forceUpdate();\n  }\n\n  public handleSpace(e: any) {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    const el: Element | null = document.elementFromPoint(\n      MousePosition.x,\n      MousePosition.y,\n    );\n\n    if (el) {\n      const parent: Element | null = el.closest('.cell-wrapper');\n\n      if (!parent) {\n        return;\n      }\n\n      const rowString: string | undefined = (parent as HTMLElement).dataset.row;\n      const colString: string | undefined = (parent as HTMLElement).dataset.col;\n\n      if (rowString && colString) {\n        const row: number = Number(rowString);\n        const col: number = Number(colString);\n        if (this.validBoundaries(row, col)) {\n          const cell = this.cells[row][col];\n          if (cell.hidden) {\n            this.handleToggleFlag(cell);\n          } else if (\n            !cell.hidden &&\n            cell.adjacentCells === this.calculateAdjacentFlaggedCells(row, col)\n          ) {\n            this.revealAdjacentUnflaggedCells(row, col);\n            this.$forceUpdate();\n          }\n        }\n      }\n    }\n  }\n\n  private created() {\n    if (this.mines - 9 > this.rows * this.cols) {\n      this.mines = this.rows * this.cols - 9;\n    }\n\n    for (let row: number = 0; row < this.rows; row++) {\n      this.cells[row] = [];\n      for (let col: number = 0; col < this.cols; col++) {\n        this.cells[row][col] = {\n          row,\n          col,\n          mine: false,\n          exploded: false,\n          hidden: true,\n          flagged: false,\n          adjacentCells: 0,\n        };\n      }\n    }\n\n    const minefield = this;\n    window.addEventListener('keypress', event => {\n      if (event.keyCode === 32) {\n        minefield.handleSpace(event);\n      }\n    });\n  }\n\n  private updated() {\n    if (!this.activeMineField) {\n      return;\n    }\n\n    this.$emit('handle-ingame');\n\n    if (this.checkLoseConditions()) {\n      this.$emit('handle-lose');\n      this.activeMineField = false;\n\n      this.revealAllCells();\n      this.$forceUpdate();\n    } else if (this.checkWinConditions()) {\n      this.$emit('handle-win');\n      this.activeMineField = false;\n\n      this.revealAllCells();\n      this.$forceUpdate();\n    }\n  }\n\n  private getRandomInt(from: number, to: number): number {\n    return Math.floor(Math.random() * to) + from;\n  }\n\n  private generateMines(initRow: number, initCol: number): void {\n    let minesToPlant: number = this.mines;\n\n    while (minesToPlant > 0) {\n      const row: number = this.getRandomInt(0, this.rows);\n      const col: number = this.getRandomInt(0, this.cols);\n\n      if (\n        !this.cells[row][col].mine &&\n        (Math.abs(initRow - row) > 1 || Math.abs(initCol - col) > 1)\n      ) {\n        this.cells[row][col].mine = true;\n        minesToPlant--;\n      }\n    }\n\n    this.minesGenerated = true;\n    this.setAdjacentCells();\n  }\n\n  private setAdjacentCells(): void {\n    for (let row: number = 0; row < this.rows; row++) {\n      for (let col: number = 0; col < this.cols; col++) {\n        this.cells[row][col].adjacentCells = this.calculateAdjacentCells(\n          row,\n          col,\n        );\n      }\n    }\n  }\n\n  private validBoundaries(row: number, col: number) {\n    return row >= 0 && row < this.rows && col >= 0 && col < this.cols;\n  }\n\n  private calculateAdjacentCells(row: number, col: number): number {\n    let adjacentCells = 0;\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (\n          this.validBoundaries(row + rowShift, col + colShift) &&\n          this.cells[row + rowShift][col + colShift].mine\n        ) {\n          adjacentCells += 1;\n        }\n      }\n    }\n\n    return adjacentCells;\n  }\n\n  private calculateAdjacentFlaggedCells(row: number, col: number): number {\n    let adjacentCells = 0;\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (\n          this.validBoundaries(row + rowShift, col + colShift) &&\n          this.cells[row + rowShift][col + colShift].flagged\n        ) {\n          adjacentCells += 1;\n        }\n      }\n    }\n\n    return adjacentCells;\n  }\n\n  private revealAllCells() {\n    for (let row: number = 0; row < this.rows; row++) {\n      for (let col: number = 0; col < this.cols; col++) {\n        this.cells[row][col].hidden = false;\n      }\n    }\n  }\n\n  private revealCells(row: number, col: number): void {\n    if (!this.minesGenerated) {\n      this.generateMines(row, col);\n    }\n\n    if (!this.cells[row][col].hidden || this.cells[row][col].flagged) {\n      return;\n    }\n\n    this.cells[row][col].hidden = false;\n\n    if (this.cells[row][col].mine) {\n      this.cells[row][col].exploded = true;\n    }\n\n    if (this.cells[row][col].adjacentCells > 0) {\n      return;\n    }\n\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (this.validBoundaries(row + rowShift, col + colShift)) {\n          this.revealCells(row + rowShift, col + colShift);\n        }\n      }\n    }\n  }\n\n  private revealAdjacentUnflaggedCells(row: number, col: number): void {\n    if (this.cells[row][col].flagged) {\n      return;\n    }\n\n    for (const rowShift of [-1, 0, 1]) {\n      for (const colShift of [-1, 0, 1]) {\n        if (\n          this.validBoundaries(row + rowShift, col + colShift) &&\n          !this.cells[row + rowShift][col + colShift].flagged\n        ) {\n          this.revealCells(row + rowShift, col + colShift);\n        }\n      }\n    }\n  }\n\n  private checkWinConditions(): boolean {\n    for (let row: number = 0; row < this.rows; row++) {\n      for (let col: number = 0; col < this.cols; col++) {\n        if (this.cells[row][col].hidden && !this.cells[row][col].mine) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  private checkLoseConditions(): boolean {\n    for (let row: number = 0; row < this.rows; row++) {\n      for (let col: number = 0; col < this.cols; col++) {\n        if (!this.cells[row][col].hidden && this.cells[row][col].mine) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"],"sourceRoot":""}]}